<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
namespace <#= TypeSymbol.ContainingNamespace.ToDisplayString() #>
{
    <#= TypeSymbol.IsStatic ? "static " : "" #>partial <#= TypeSymbol.IsValueType ? "struct " : "class " #> <#= TypeSymbol.Name #>
    {
        [global::Unity.Burst.BurstCompile]
        public unsafe struct CollisionJob : global::Unity.Jobs.IJob
        {
<# for (var index = 0; index < Outers.Length; ++index) { var item = Outers[index]; #>
            <# if (item.IsReadOnly) { #>[global::Unity.Collections.ReadOnly] <# } #>public global::Unity.Collections.NativeArray<<#= item.Symbol.ToDisplayString() #>.Eight> Outer<#= index #>;
<# } #>

<# for (var index = 0; index < Inners.Length; ++index) { var item = Inners[index]; #>
            <# if (item.IsReadOnly) { #>[global::Unity.Collections.ReadOnly] <# } #>public global::Unity.Collections.NativeArray<<#= item.Symbol.ToDisplayString() #>.Eight> Inner<#= index #>;
<# } #>

            public void Execute()
            {
<# if (Fma.HasValue) { var method = Fma.Value; #>
                if (global::Unity.Burst.Intrinsics.X86.Fma.IsFmaSupported)
                {
                    for (var outerIndex = 0; outerIndex < Outer0.Length; ++outerIndex)
                    {
<# for (var index = 0; index < Outers.Length; ++index) {
    var item = Outers[index]; #>
                        var outer<#= index #> = Outer<#= index #>[outerIndex];
<# } #>
<# for (var index = 0; index < method.OuterLoopParameters.Length; ++index) {
    var item = method.OuterLoopParameters[index];
    var name = "outer" + item.Index + "_" + item.Name; #>
                        var <#= name #>0 = *(global::Unity.Burst.Intrinsics.v256*)&(outer<#= item.Index #>.<#= item.Name #>);
                        var <#= name #>1 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(<#= name #>0, 0b00_11_10_01);
                        var <#= name #>2 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(<#= name #>0, 0b01_00_11_10);
                        var <#= name #>3 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(<#= name #>0, 0b10_01_00_11);
                        var <#= name #>4 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute2f128_ps(<#= name #>0, <#= name #>0, 0b0000_0001);
                        var <#= name #>5 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(<#= name #>4, 0b00_11_10_01);
                        var <#= name #>6 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(<#= name #>4, 0b01_00_11_10);
                        var <#= name #>7 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(<#= name #>4, 0b10_01_00_11);
<# } #>

                        for (var innerIndex = 0; innerIndex < Inner0.Length; ++innerIndex)
                        {
<# for (var index = 0; index < Inners.Length; ++index) {
    var item = Inners[index]; #>
                            var inner<#= index #> = Inner<#= index #>[innerIndex];
<# } #>
<# for (var index = 0; index < method.InnerLoopParameters.Length; ++index) {
    var item = method.InnerLoopParameters[index];
    var name = "inner" + item.Index + "_" + item.Name; #>
                            var <#= name #> = *(global::Unity.Burst.Intrinsics.v256*)&(inner<#= item.Index #>.<#= item.Name #>);
<# } #>

<# var parameters = method.OuterLoopParameters.Concat(method.InnerLoopParameters).OrderBy(x => x.Symbol.Ordinal);
for (var counter = 0; counter < 8; ++counter) { #>
                           <#= method.Symbol.Name #>(<# bool first = true; foreach (var parameter in parameters) { if (!first) { #>, <# } first = false; #>ref <#= parameter.IsOuter ? "outer" : "inner" #><#= parameter.Index #>_<#= parameter.Name #><#= parameter.IsOuter ? counter : "" #><# } #>);
<# } #>
<# for (var index = 0; index < method.InnerLoopParameters.Length; ++index) {
    var item = method.InnerLoopParameters[index];
    if (Inners[item.Index].IsReadOnly) continue;
    var name = "inner" + item.Index + "_" + item.Name; #>
                            *(global::Unity.Burst.Intrinsics.v256*)&(inner<#= item.Index #>.<#= item.Name #>) = <#= name #>;
<# } #>
<# for (var index = 0; index < Inners.Length; ++index) {
    var item = Inners[index];
    if (item.IsReadOnly) { continue; } #>
                            Inner<#= index #>[innerIndex] = inner<#= index #>;
<# } #>
                        }

<# foreach (var item in method.Closers) {
    var name = "outer" + item.Index + "_" + item.Name; #>
                        <#= name #>1 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(<#= name #>1, 0b10_01_00_11);
                        <#= name #>2 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(<#= name #>2, 0b01_00_11_10);
                        <#= name #>3 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(<#= name #>3, 0b00_11_10_01);
                        <#= name #>4 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute2f128_ps(<#= name #>4, <#= name #>4, 0b0000_0001);
                        <#= name #>5 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute2f128_ps(<#= name #>5, <#= name #>5, 0b0000_0001), 0b10_01_00_11);
                        <#= name #>6 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute2f128_ps(<#= name #>6, <#= name #>6, 0b0000_0001), 0b01_00_11_10);
                        <#= name #>7 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute2f128_ps(<#= name #>7, <#= name #>7, 0b0000_0001), 0b00_11_10_01);
                        *(global::Unity.Burst.Intrinsics.v256*)&(outer<#= item.Index #>.<#= item.Name #>) = <#= item.Symbol.Name #>(<#= name #>0, <#= name #>1, <#= name #>2, <#= name #>3, <#= name #>4, <#= name #>5, <#= name #>6, <#= name #>7);
<# } #>
<# for (var index = 0; index < Outers.Length; ++index) {
    var item = Outers[index];
    if (item.IsReadOnly) { continue; } #>
                        Outer<#= index #>[outerIndex] = outer<#= index #>;
<# } #>
                    }
                    
                    return;
                }
<# } #>
<# { var method = Ordinal; #>
                {
                    for (var outerIndex = 0; outerIndex < Outer0.Length; ++outerIndex)
                    {
<# for (var index = 0; index < Outers.Length; ++index) {
    var item = Outers[index]; #>
                        var outer<#= index #> = Outer<#= index #>[outerIndex];
<# } #>
<# for (var index = 0; index < method.OuterLoopParameters.Length; ++index) {
    var item = method.OuterLoopParameters[index];
    var name = "outer" + item.Index + "_" + item.Name; #>
                        var <#= name #>0 = outer<#= item.Index #>.<#= item.Name #>;
                        global::MyAttribute.RotateHelper.Rotate(<#= name #>0, out var <#= name #>1, out var <#= name #>2, out var <#= name #>3, out var <#= name #>4, out var <#= name #>5, out var <#= name #>6, out var <#= name #>7);
<# } #>

                        for (var innerIndex = 0; innerIndex < Inner0.Length; ++innerIndex)
                        {
<# for (var index = 0; index < Inners.Length; ++index) {
    var item = Inners[index]; #>
                            var inner<#= index #> = Inner<#= index #>[innerIndex];
<# } #>
<# for (var index = 0; index < method.InnerLoopParameters.Length; ++index) {
    var item = method.InnerLoopParameters[index];
    var name = "inner" + item.Index + "_" + item.Name; #>
                            ref var <#= name #> = ref inner<#= item.Index #>.<#= item.Name #>;
<# } #>

<# var parameters = method.OuterLoopParameters.Concat(method.InnerLoopParameters).OrderBy(x => x.Symbol.Ordinal);
    for (var counter = 0; counter < 8; ++counter) { #>
                            <#= method.Symbol.Name #>(<# bool first = true; foreach (var parameter in parameters) { if (!first) { #>, <# } first = false; #>ref <#= parameter.IsOuter ? "outer" : "inner" #><#= parameter.Index #>_<#= parameter.Name #><#= parameter.IsOuter ? counter : "" #><# } #>);
<# } #>
<# for (var index = 0; index < Inners.Length; ++index) {
    var item = Inners[index];
    if (item.IsReadOnly) { continue; } #>
                            Inner<#= index #>[innerIndex] = inner<#= index #>;
<# } #>
                        }

<# foreach (var item in method.Closers) {
    var name = "outer" + item.Index + "_" + item.Name; #>
                        global::MyAttribute.RotateHelper.RotateM1(ref <#= name #>1, ref <#= name #>2, ref <#= name #>3, ref <#= name #>4, ref <#= name #>5, ref <#= name #>6, ref <#= name #>7);
                        outer<#= item.Index #>.<#= item.Name #> = <#= item.Symbol.Name #>(<#= name #>0, <#= name #>1, <#= name #>2, <#= name #>3, <#= name #>4, <#= name #>5, <#= name #>6, <#= name #>7);
<# } #>
<# for (var index = 0; index < Outers.Length; ++index) {
    var item = Outers[index];
    if (item.IsReadOnly) { continue; } #>
                        Outer<#= index #>[outerIndex] = outer<#= index #>;
<# } #>
<# } #>
                    }
                }
            }
        }
    }
}
