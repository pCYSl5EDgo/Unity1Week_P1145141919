<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
namespace <#= TypeSymbol.ContainingNamespace.ToDisplayString() #>
{
    <#= TypeSymbol.IsStatic ? "static " : "" #>partial <#= TypeSymbol.IsValueType ? "struct " : "class " #> <#= TypeSymbol.Name #>
    {
        [global::Unity.Burst.BurstCompile]
        public unsafe struct CollisionJob : global::Unity.Jobs.IJob
        {
<# for (var index = 0; index < Outers.Length; ++index) {
    var item = Outers[index]; #>
            <# if (item.IsReadOnly) { #>[global::Unity.Collections.ReadOnly] <# } #>public global::Unity.Collections.NativeArray<<#= item.Symbol.ToDisplayString() #>.Eight> Outer<#= index #>;
<# } #>
<# for (var index = 0; index < Inners.Length; ++index) {
    var item = Inners[index]; #>
            <# if (item.IsReadOnly) { #>[global::Unity.Collections.ReadOnly] <# } #>public global::Unity.Collections.NativeArray<<#= item.Symbol.ToDisplayString() #>.Eight> Inner<#= index #>;
<# } #>
<# for (var index = 0; index < Others.Length; ++index) {
    var item = Others[index]; 
    if (item.IsReadOnly) { #>
            public <#= item.Symbol.ToDisplayString() #> Other<#= index #>;
<# } else { #>
            public global::Unity.Collections.NativeArray<<#= item.Symbol.ToDisplayString() #>> Other<#= index #>;
<# } #>
<# } #>
<# for (var index = 0; index < Tables.Length; ++index) {
    var item = Tables[index]; #>
            <# if (item.IsReadOnly) { #>[global::Unity.Collections.ReadOnly] <# } #>public global::Unity.Collections.NativeArray<<#= item.Symbol.ToDisplayString() #>> Table<#= index #>;
<# } #>

            public void Execute()
            {
<# if (Fma.HasValue) { var method = Fma.Value; #>
                if (global::Unity.Burst.Intrinsics.X86.Fma.IsFmaSupported)
                {
                    const int next1 = 0b00_11_10_01;
                    const int next2 = 0b01_00_11_10;
                    const int next3 = 0b10_01_00_11;
<# for (var index = 0; index < Others.Length; ++index) {
    var item = Others[index];
    if (item.IsReadOnly) { #>
                    var other<#= index #> = new global::Unity.Burst.Intrinsics.v256(Other<#= index #>, Other<#= index #>, Other<#= index #>, Other<#= index #>, Other<#= index #>, Other<#= index #>, Other<#= index #>, Other<#= index #>);
<# } else { #>
                    var other<#= index #> = Other<#= index #>[0];
<# } #>
<# } #>
<# for (var index = 0; index < Outers.Length; ++index) {
    var item = Outers[index]; #>
                    var outerPointer<#= index #> = (byte*)global::Unity.Collections.LowLevel.Unsafe.NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(Outer<#= index #>);
<# } #>
<# for (var index = 0; index < Inners.Length; ++index) {
    var item = Inners[index]; #>
                    var innerOriginalPointer<#= index #> = (byte*)global::Unity.Collections.LowLevel.Unsafe.NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(Inner<#= index #>);
<# } #>

                    for (
                        var outerIndex = 0;
                        outerIndex < Outer0.Length;
                        ++outerIndex<# for (var index = 0; index < Outers.Length; ++index) { #>,
                        outerPointer<#= index #> += sizeof(<#= Outers[index].Symbol.ToDisplayString() #>.Eight)<# } #>

                    )
                    {
<# for (var index = 0; index < method.Outers.Length; ++index) {
    var item = method.Outers[index];
    var fieldIndex = item.GetIndex(Outers[item.Index].Symbol);
    var name = "outer" + item.Index + "_" + item.Name; #>
                        var <#= name #> = outerPointer<#= item.Index #> + (<#= fieldIndex #> << 5);
<# } #>

<# for (var index = 0; index < method.Outers.Length; ++index) {
    var item = method.Outers[index];
    var fieldIndex = item.GetIndex(Outers[item.Index].Symbol);
    var name = "outer" + item.Index + "_" + item.Name; #>
                        var <#= name #>0 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_load_ps(<#= name #>);
<# } #>

<# for (var nextIndex = 1; nextIndex < 4; ++nextIndex) {
     for (var index = 0; index < method.Outers.Length; ++index) {
      var item = method.Outers[index];
      var fieldIndex = item.GetIndex(Outers[item.Index].Symbol);
      var name = "outer" + item.Index + "_" + item.Name; #>
                        var <#= name #><#= nextIndex #> = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(<#= name #>0, next<#= nextIndex #>);
<# } #>
<# } #>

<# for (var index = 0; index < method.Outers.Length; ++index) {
    var item = method.Outers[index];
    var fieldIndex = item.GetIndex(Outers[item.Index].Symbol);
    var name = "outer" + item.Index + "_" + item.Name; #>
                        var <#= name #>4 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute2f128_ps(<#= name #>0, <#= name #>0, 0b0000_0001);
<# } #>

<# for (var nextIndex = 1; nextIndex < 4; ++nextIndex) {
      for (var index = 0; index < method.Outers.Length; ++index) {
        var item = method.Outers[index];
        var fieldIndex = item.GetIndex(Outers[item.Index].Symbol);
        var name = "outer" + item.Index + "_" + item.Name; #>
                        var <#= name #><#= nextIndex + 4 #> = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(<#= name #>4, next<#= nextIndex #>);
<# } #>
<# } #>

<# for (var index = 0; index < Inners.Length; ++index) { #>
                        var innerPointer<#= index #> = innerOriginalPointer<#= index #>;
<# } #>
                        for (
                            var innerIndex = 0;
                            innerIndex < Inner0.Length;
                            ++innerIndex<# for (var index = 0; index < Inners.Length; ++index) { #>,
                            innerPointer<#= index #> += sizeof(<#= Inners[index].Symbol.ToDisplayString() #>.Eight)<# } #>

                        )
                        {
<# for (var index = 0; index < method.Inners.Length; ++index) {
    var item = method.Inners[index];
    var fieldIndex = item.GetIndex(Inners[item.Index].Symbol);
    var name = "inner" + item.Index + "_" + item.Name; #>
                            var <#= name #> = global::Unity.Burst.Intrinsics.X86.Avx.mm256_load_ps(innerPointer<#= item.Index #> + (<#= fieldIndex #> << 5));
<# } #>

<# for (var counter = 0; counter < 8; ++counter) {
    var parameter = method.Outers[0]; #>
                            <#= method.Symbol.Name #>(ref outer<#= parameter.Index #>_<#= parameter.Name #><#= counter #><# for (var index = 1; index < method.Outers.Length; ++index) { parameter = method.Outers[index]; #>, ref outer<#= parameter.Index #>_<#= parameter.Name #><#= counter #><# } for (var index = 0; index < method.Inners.Length; ++index) { parameter = method.Inners[index]; #>, ref inner<#= parameter.Index #>_<#= parameter.Name #><# } for (var index = 0; index < method.Others.Length; ++index) { parameter = method.Others[index]; #>, ref other<#= parameter.Index #><# } for (var index = 0; index < method.Tables.Length; ++index) { parameter = method.Tables[index]; #>, ref Table<#= parameter.Index #><# } #>);
<# } #>
<# for (var index = 0; index < method.Inners.Length; ++index) {
    var item = method.Inners[index];
    var typeItem = Inners[item.Index];
    var fieldIndex = item.GetIndex(typeItem.Symbol);
    if (typeItem.IsReadOnly) continue;
    var name = "inner" + item.Index + "_" + item.Name; #>
                            global::Unity.Burst.Intrinsics.X86.Avx.mm256_store_ps(innerPointer<#= item.Index #> + (<#= fieldIndex #> << 5), <#= name #>);
<# } #>
                        }

<# foreach (var item in method.Closers) {
    if (item.FieldKind != CollisionFieldKind.Outer) continue;
    var name = "outer" + item.Index + "_" + item.Name; #>
                        <#= name #>1 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(<#= name #>1, 0b10_01_00_11);
                        <#= name #>2 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(<#= name #>2, 0b01_00_11_10);
                        <#= name #>3 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(<#= name #>3, 0b00_11_10_01);
                        <#= name #>4 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute2f128_ps(<#= name #>4, <#= name #>4, 0b0000_0001);
                        <#= name #>5 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute2f128_ps(<#= name #>5, <#= name #>5, 0b0000_0001), 0b10_01_00_11);
                        <#= name #>6 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute2f128_ps(<#= name #>6, <#= name #>6, 0b0000_0001), 0b01_00_11_10);
                        <#= name #>7 = global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute_ps(global::Unity.Burst.Intrinsics.X86.Avx.mm256_permute2f128_ps(<#= name #>7, <#= name #>7, 0b0000_0001), 0b00_11_10_01);
                        global::Unity.Burst.Intrinsics.X86.Avx.mm256_store_ps(<#= name #>, <#= item.Symbol.Name #>(<#= name #>0, <#= name #>1, <#= name #>2, <#= name #>3, <#= name #>4, <#= name #>5, <#= name #>6, <#= name #>7));
<# } #>
                    }
<# for (var index = 0; index < Others.Length; ++index) {
    var item = Others[index];
    if (item.IsReadOnly) { continue; } #>

                    Other<#= index #>[0] = other<#= index #>;
<# } #>
                    return;
                }

<# } #>
<# { var method = Ordinal; #>
                {
<# for (var index = 0; index < Others.Length; ++index) {
    var item = Others[index];
    if (item.IsReadOnly) { #>
                    var other<#= index #> = new global::Unity.Mathematics.<#= item.Symbol.ToDisplayString() #>4(Other<#= index #>, Other<#= index #>, Other<#= index #>, Other<#= index #>);
<# } else { #>
                    var other<#= index #> = Other<#= index #>[0];
<# } #>
<# } #>
                    for (var outerIndex = 0; outerIndex < Outer0.Length; ++outerIndex)
                    {
<# for (var index = 0; index < Outers.Length; ++index) {
    var item = Outers[index]; #>
                        var outer<#= index #> = Outer<#= index #>[outerIndex];
<# } #>
<# for (var index = 0; index < method.Outers.Length; ++index) {
    var item = method.Outers[index];
    var name = "outer" + item.Index + "_" + item.Name; #>
                        ref var <#= name #>0 = ref outer<#= item.Index #>.<#= item.Name #>;
                        ref var <#= name #>0_c0 = ref <#= name #>0.c0;
                        var <#= name #>1_c0 = <#= name #>0.c0.wxyz;
                        var <#= name #>2_c0 = <#= name #>0.c0.zwxy;
                        var <#= name #>3_c0 = <#= name #>0.c0.yzwx;
                        ref var <#= name #>0_c1 = ref <#= name #>0.c1;
                        var <#= name #>1_c1 = <#= name #>0_c1.wxyz;
                        var <#= name #>2_c1 = <#= name #>0_c1.zwxy;
                        var <#= name #>3_c1 = <#= name #>0_c1.yzwx;
<# } #>
                        for (var innerIndex = 0; innerIndex < Inner0.Length; ++innerIndex)
                        {
<# for (var index = 0; index < Inners.Length; ++index) {
    var item = Inners[index]; #>
                            var inner<#= index #> = Inner<#= index #>[innerIndex];
<# } #>
<# for (var index = 0; index < method.Inners.Length; ++index) {
    var item = method.Inners[index];
    var name = "inner" + item.Index + "_" + item.Name; #>
                            ref var <#= name #> = ref inner<#= item.Index #>.<#= item.Name #>;
<# } #>

<# for (var counter = 0; counter < 4; ++counter) {
    for (var cIndex0 = 0; cIndex0 < 2; ++cIndex0) {
      for (var cIndex1 = 0; cIndex1 < 2; ++cIndex1) {
        var parameter = method.Outers[0]; #>
                            <#= method.Symbol.Name #>(ref outer<#= parameter.Index #>_<#= parameter.Name #><#= counter #>_c<#= cIndex0 #><# for (var index = 1; index < method.Outers.Length; ++index) { parameter = method.Outers[index]; #>, ref outer<#= parameter.Index #>_<#= parameter.Name #><#= counter #>_c<#= cIndex0 #><# } for (var index = 0; index < method.Inners.Length; ++index) { parameter = method.Inners[index]; #>, ref inner<#= parameter.Index #>_<#= parameter.Name #>.c<#= cIndex1 #><# } for (var index = 0; index < method.Others.Length; ++index) { parameter = method.Others[index]; #>, ref other<#= parameter.Index #><# } for (var index = 0; index < method.Tables.Length; ++index) { parameter = method.Tables[index]; #>, ref Table<#= parameter.Index #><# } #>);
<# } #>
<# } #>
<# } #>
<# for (var index = 0; index < Inners.Length; ++index) {
    var item = Inners[index];
    if (item.IsReadOnly) { continue; } #>
                            Inner<#= index #>[innerIndex] = inner<#= index #>;
<# } #>
                        }
<# foreach (var item in method.Closers) {
    if (item.FieldKind != CollisionFieldKind.Outer) continue;
    var name = "outer" + item.Index + "_" + item.Name; #>

                        <#= name #>0.c0 = <#= item.Symbol.Name #>(<#= name #>0.c0, <#= name #>1_c0.yzwx, <#= name #>2_c0.zwxy, <#= name #>3_c0.wxyz);
                        <#= name #>0.c1 = <#= item.Symbol.Name #>(<#= name #>0.c1, <#= name #>1_c1.yzwx, <#= name #>2_c1.zwxy, <#= name #>3_c1.wxyz);
<# } #>
<# for (var index = 0; index < Outers.Length; ++index) {
    var item = Outers[index];
    if (item.IsReadOnly) { continue; } #>
                        Outer<#= index #>[outerIndex] = outer<#= index #>;
<# } #>
<# } #>
                    }
<# for (var index = 0; index < Others.Length; ++index) {
    var item = Others[index];
    if (item.IsReadOnly) { continue; } #>

                    Other<#= index #>[0] = other<#= index #>;
<# } #>
                }
            }
        }
    }
}
